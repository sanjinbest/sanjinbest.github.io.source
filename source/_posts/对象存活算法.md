---
title: 对象存活算法
date: 2018-02-24 15:48:36
tags:
- JVM
categories:
- JVM
---

在堆里存入放java世界中几乎所有的对象实例，垃圾收集器在对堆进行回收前，第一件事情就是要确定哪些对象还“活着”，哪些已经“死去”。

<!-- more -->

#### 引用计数算法
引用计数器算法（Reference Counting）：给对象添加一个引用计数器，每当有一个地方引用它时，计数器加1；当引用失效时，计数器减1；任何时刻计数器为0的对象就是不可能再被使用的。
客观的说，引用计数器算法的实现简单，判定效率也很高，在大部分情况下是一个不错的算法，但它很难解决对象之间相互循环的问题。

#### 可达性分析算法
可达性分析算法（Reachability Analysis）这个算法的基本思路就是通过一系列称为“GC Root”的对象作为起点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Root没有任何引用链相连时，则证明此对象是不可用的。
在Java语言中可作为GC Root的对象包括下面几种：
- 虚拟机栈（栈帧中的本地变量表）中引用的对象。
- 方法区中类静态属性引用的对象。
- 方法区中常量引用的对象。
- 本地方法栈中JNI（即一般说的Native方法）引用的对象。

#### Java引用的扩充
对于对象我们希望：当内存空间还足够时，则能保留在内存之中；如果内存空间在进行垃圾收集后还是非常紧张，则可以抛弃这些对象。
JDK 1.2之后，Java对引用的概念进行了扩充，将引用分为以下4种：
- 强引用（Strong Reference）：在程序代码中普遍存在的，类似 Object obj = new Object(); 这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉**被引用**的对象。
- 软引用（Soft Reference）：描述一些还有用但并非必需的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常，在JDK 1.2之后 ，提供了SoftReference类来实现软引用。
- 弱引用（Weak Reference）：描述非必需的对象，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在JDK1.2 之后，提供了WeakReference类来实现弱引用。
- 虚引用（Phantom Reference）：也称为幽灵引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。在JDK 1.2之后 提供了PhatomReference类来实现虚引用。

#### 方法区的回收
方法区（或者HotSpot虚拟机中的永久代）的回收，主要回收两部分内容：废弃常量和无用的类。
回收废弃的常量与回收Java堆中的对象类似。
回收无用的类时，类需要满足下面3个条件：
- 该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例。
- 加载该类的ClassLoader已经被回收。
- 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。