---
title: 排序算法之插入排序
date: 2018-02-26 10:52:49
tags:
- 排序
- 算法
categories:
- 排序算法
---

## 算法思想
插入排序的基本思想是：每步将一个待排序的记录，按其关键码值的大小插入前面已经排序的文件中适当位置上，直到全部插入完为止。
也可理解为：将一个记录插入到已排序好的有序表中，从而得到一个新的记录数增1的有序表。即：先将序列的第1个记录看成是一个有序的子序列，然后从第2个记录逐个进行插入，直至整个序列有序为止。
要点：设立哨兵，作为临时存储和判断数组边界之用。

<!-- more -->

## 算法步骤
⒈ 从有序数列和无序数列{a2,a3，…，an}开始进行排序；
⒉ 处理第i个元素时（i=2,3，…，n），数列{a1,a2，…，ai-1}是已有序的，而数列{ai,ai+1，…，an}是无序的。用ai与ai-1，a i-2，…，a1进行比较，找出合适的位置将ai插入；
⒊ 重复第二步，共进行n-i次插入处理，数列全部有序。
## 算法复杂度
如果目标是把n个元素的序列升序排列，那么采用插入排序存在最好情况和最坏情况。
- 最好情况就是，序列已经是升序排列了，在这种情况下，需要进行的比较操作需**（n-1）**次即可。
- 最坏情况就是，序列是降序排列，那么此时需要进行的比较共有**n(n-1)/2**次。
- 插入排序的赋值操作是比较操作的次数加上 (n-1）次。平均来说插入排序算法的时间复杂度为O(n^2）。
- 因而，插入排序不适合对于数据量比较大的排序应用。但是，如果需要排序的数据量很小，例如，量级小于千，那么插入排序还是一个不错的选择。
## 算法稳定性
插入排序是在一个已经有序的小序列的基础上，一次插入一个元素。当然，刚开始这个有序的小序列只有1个元素，就是第一个元素。比较是从有序序列的末尾开始，也就是想要插入的元素和已经有序的最大者开始比起，如果比它大则直接插入在其后面，否则一直往前找直到找到它该插入的位置。如果碰见一个和插入元素相等的，那么插入元素把想插入的元素放在相等元素的后面。所以，相等元素的前后顺序没有改变，从原无序序列出去的顺序就是排好序后的顺序，所以插入排序是稳定的。
## 算法描述（JAVA）
```
public void insertSort(int arr[]) {
        for(int i= 1; i<arr.length; i++){
            if(arr[i] < arr[i-1]){//如果小于前一位，开始定位插入位置
                int j = i-1; //标记开始后移的位置
                int temp = arr[i];  //临时存储待插入数据
                while(j > -1 && temp < arr[j]){ //遍历定位位置同时向后移动
                    arr[j+1] = arr[j];
                    j--;
                }
                arr[j+1] = temp;
            }
        }
    }
```
## 参考文章
  1. [八大排序算法-直接插入排序](http://blog.csdn.net/hguisu/article/details/7776068)
2. [插入排序-百度百科](https://baike.baidu.com/item/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/7214992?fr=aladdin)
