title: 算法时间复杂度计算方法
author: 木子三金
tags:
  - 算法
  - 时间复杂度
categories:
  - 数据结构
  - ''
date: 2018-11-14 17:01:00
---
## 时间复杂度定义
>在进行算法分析时，语句总的执行次数T(n)是关于问题规模n的函数，进而分析T(n)随n的变化情况并确定T(n)的数量级。算法的时间复杂度，也就是算法的时间量度，记作：T(n) = O(f(n))。它表示随问题规模n的增大，算法执行时间的增长率和f(n)的增长率相同，称作算法的渐近时间复杂度，简称为时间复杂度。其中f(n)是问题规模n的某个函数。

这样用大写O()来体现算法的时间复杂度的记法，我们称之为大O记法。
<!-- more -->

## 推导大O阶方法
如何分析一个算法的时间复杂度呢？即如何推导大O阶呢？我们可以参考下面的推导方法。

	推导大O阶：
	1. 用常数1取代运行时间中的所有加法常数。
	2. 在修改后的运行次数函数中，只保留最高阶项。
	3. 如果最高阶项存在且不是1，则去除与这个项相乘的常数。
	得到的结果就是大O阶。
下面让我们根据这个推导方法来看几个例子。


## 常数阶
```
int sum = 0,n = 100;  /* 执行一次 */
sum = (1 + n) * n/2;  /* 执行一次 */
System.out.println(sum);  /* 执行一次 */
```
这段程序的执行次数是f(3)。我们使用大O阶的方法推导一下：
1. 将常数项3改为1。
2. 保留最高阶项。

	没有最高阶项，所以这段程序的时间复杂度为O(1).

可以试想一下，如果这段代码里的
```
sum = (1 + n) * n/2;  /* 执行一次 */
```
一共有10句，那么时间复杂度是多少呢？

事实上，无论有多少句该代码，都不过是3次和12次的执行差异。像这种**执行时间恒定**的算法，我们称之为具有O(1)的时间复杂度，又叫**常数阶**。

***注意：无论这个常数是多少，我们都记作O(1)。***

同理，对于单纯分支结构（不包含在循环中的if或switch语句）而言，执行的次数都是恒定的，其时间复杂度也是O(1)。

## 线性阶

线性阶的循环结构会复杂一些。要确定某个算法的阶次，我们常常需要确定某个特定语句或某个语句集的运行次数。因此，我们要**分析算法的复杂度，关键就是要分析循环结构的运行情况。**

下面这段代码，它的循环时间复杂度为O(n)，因为循环中的代码须要执行n次。
```
for(int i = 0; i < n; i++){
}
```

## 对数阶

## 平方阶

## 常见的时间复杂度